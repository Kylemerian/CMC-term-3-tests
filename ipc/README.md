Общая идея следующая. Одна программа создаёт в разделяемой памяти массив
из десяти целых чисел, заносит в него нули, а затем в цикле, пока вы её не
пришибёте, считает сумму элементов массива, печатает её, спит одну секунду,
снова считает сумму и т.д. Естественно, пока мы не запустим вторую
программу, сумма получается всегда ноль.

Вторая программа подключается к той же самой разделяемой памяти (для этого
потребуется изначально сгенерировать ключ с помощью ftok), а затем тоже
работает в цикле: берёт два случайных числа от 0 до 9 (например, дважды
вычисляет rand()%10), использует эти числа как индексы в массиве, к первому
выбранному элементу массива прибавляет единицу, от второго отнимает
единицу. Ясно, что общая сумма при этом вроде бы должна остаться нулевая.
Эта ("вторая") программа не спит -- она свой цикл крутит настолько быстро,
насколько это возможно.

По идее (это вам на лекциях говорили) такой доступ к разделяемой памяти
нужно взаимоисключать, то есть заводить семафор с начальным значением 1,
перед обращением к массиву его опускать, после обращения поднимать обратно.
Но для иллюстративных целей первую версию своих программ семафорами не
снабжайте. Дело тут в том, что -- знаю по себе -- в "эффекты" от коллизий
при обращении к разделяемой памяти очень сложно поверить, пока не увидишь
их сам. Так вот, запускаете первую программу, она печатает нолики раз
в секунду. В другом окошке запускаете вторую программу. Первая продолжает
печатать нолики, изредка она будет печатать числа, чуть-чуть отличающиеся
от нуля, но потом снова возвращаться к нулю. Теперь в третьем окошке
запускаете второй экземпляр второй программы -- и наблюдаете, как сумма,
которая вроде бы должна оставаться нулевой, быстро и эффективно "улетает в
космос" (обычно она шестизначных значений достигает за первые пять-шесть
секунд одновременной работы двух экземпляров второй программы).

Теперь второй этап: снабжаете свои программы механизмом взаимоисключения.
Первая программа вместе с разделяемой памятью создаёт ещё и массив из
одного семафора, заносит в семафор начальное значение (1) и дальше перед
каждым подсчётом суммы опускает семафор, после окончания подсчёта --
поднимает обратно и только после этого уходит печатать сумму и спать.
Вторая программа подключается сразу и к памяти, и к семафору, далее в цикле
сначала берёт случайные числа, затем выстраивает критическую секцию --
опускает семафор, прибавляет единицу к одному элементу, вычитает единицу из
другого (или наоборот, как вам больше нравится), поднимает семафор.
Запускаете их в таком виде и убеждаетесь, что теперь сумма, печатаемая
первой программой, всегда равна нулю. Для наглядности можете печатать не
только сумму, но и весь массив, в смысле значения всех десяти его элементов
-- это чтобы было видно, что сами элементы давно уже не нули, но сумма
по-прежнему ноль.

После этого обычно остаточное неверие в опасности разделяемых данных
испаряется.

Для работы вам потребуется, во-первых, функция ftok. Первым параметром
должен быть какой-то _существующий_ файл, например, текущая директория "."
или какой-нибудь специально созданный пустой файл в ней. Важно, чтобы этот
файл существовал и не перезаписывался во время работы ваших программ;
содержимое файла неважно, как и его тип. Второй параметр -- произвольный
char, можно, например, для памяти использовать 'a', а для семафоров - 'b'.

Во-вторых, средства работы с разделяемой памятью: shmget создаёт в ядре
объект разделяемой памяти или, если объект с заданным ключом уже есть,
подключается к нему; первым параметром она получает ключ, сгенерированный
ftok'ом, второй параметр -- размер (в вашем случае, например,
10*sizeof(int), то есть 40), третий параметр -- 0666|IPC_CREAT для первой
программы, просто 0666 для второй, это права доступа к объекту. Далее вам
потребуется shmat, чтобы отобразить разделяемую память на виртуальное
адресное пространство вашей программы. Первый параметр -- число,
полученное от shmget (дескриптор объекта), второй и третий оставляем NULL и
0 соответственно. Чтобы использовать полученную память как массив int'ов,
соответствующим образом преобразуем полученный адрес, например:

    int *vec;
      /* ... */
    vec = shmat(id, NULL, 0);

Может пригодиться ещё shmctl для уничтожения объекта, но тогда надо
придумать какой-то способ корректного завершения обеих программ или хотя бы
первой (а не просто их пришибать).

В-третьих, для семафоров потребуется semget (работает аналогично shmget'у,
только второй параметр -- это количество семафоров в массиве, указываете 1),
semop для выполнения up и down (читайте описания, если непонятно --
задавайте вопросы), semctl (эта нужна не только для удаления, но и для
задания начального значения семафора -- опять же, читайте описание, но в
общем что-то вроде semctl(id, 0, SETVAL, 1)).

Ещё вам однозначно потребуются команды командной строки, про которые вам на
лекции могли и не сказать -- ipcs и ipcrm (первая показывает, какие в
системе есть объекты SysV IPC, вторая позволяет удалить объект). Без этих
команд иметь дело с IPC, как по мне, вообще невозможно.